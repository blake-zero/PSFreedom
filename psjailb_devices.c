/*
 * psjailbreak.c -- PS3 Jailbreak exploit Gadget Driver
 *
 * Copyright (C) Youness Alaoui
 *
 * This software is distributed under the terms of the GNU General Public
 * License ("GPL") version 2, as published by the Free Software Foundation.
 *
 * This code is based in part on:
 *
 * USB MIDI Gadget Driver, Copyright (C) 2006 Thumtronics Pty Ltd.
 * Gadget Zero driver, Copyright (C) 2003-2004 David Brownell.
 * USB Audio driver, Copyright (C) 2002 by Takashi Iwai.
 * USB MIDI driver, Copyright (C) 2002-2005 Clemens Ladisch.
 *
 */

#define DEBUG
#define VERBOSE_DEBUG

#include <linux/kernel.h>
#include <linux/utsname.h>
#include <linux/device.h>

#include <sound/core.h>
#include <sound/initval.h>
#include <sound/rawmidi.h>

#include <linux/usb/ch9.h>
#include <linux/usb/gadget.h>

#include "../kernel-2.6.28/drivers/usb/gadget/epautoconf.c"
#include "../kernel-2.6.28/drivers/usb/gadget/config.c"
#include "hub.h"

/*-------------------------------------------------------------------------*/


MODULE_AUTHOR("Youness Alaoui");
MODULE_LICENSE("GPL v2");

#define DRIVER_VERSION "29 August 2010"

static const char shortname[] = "ps3jailbreak";
static const char longname[] = "PS3 Jailbreak exploit";


static ushort idVendor;
module_param(idVendor, ushort, S_IRUGO);
MODULE_PARM_DESC(idVendor, "USB Vendor ID");

static ushort idProduct;
module_param(idProduct, ushort, S_IRUGO);
MODULE_PARM_DESC(idProduct, "USB Product ID");

/* big enough to hold our biggest descriptor */
#define USB_BUFSIZ 4000


struct hub_port {
  int connect;
  int enable;
  int suspend;
  int reset;
  int power;
  int low_speed;
  int high_speed;
  int connect_changed;
  int enable_changed;
  int suspend_changed;
  int reset_changed;
};

enum {INIT_HUB, CONNECT_DEVICE_1, } PsjailbState;

struct psjailb_device {
  spinlock_t		lock;
  struct usb_gadget	*gadget;
  struct usb_request	*req;		/* for control responses */
  u8			config;
  struct usb_ep		*in_ep;
  struct hub_port	hub_ports[6];
  enum PsjailbState	state;
};


#define DBG(d, fmt, args...)                    \
  dev_dbg(&(d)->gadget->dev , fmt , ## args)
#define VDBG(d, fmt, args...)                   \
  dev_vdbg(&(d)->gadget->dev , fmt , ## args)
#define ERROR(d, fmt, args...)                  \
  dev_err(&(d)->gadget->dev , fmt , ## args)
#define INFO(d, fmt, args...)                   \
  dev_info(&(d)->gadget->dev , fmt , ## args)

static void hub_transmit(struct psjailb_device *dev, struct usb_request *req);

/* Taking first HUB vendor/product ids from http://www.linux-usb.org/usb.ids
 *
 * DO NOT REUSE THESE IDs with a protocol-incompatible driver!!  Ever!!
 * Instead:  allocate your own, using normal USB-IF procedures.
 */
#define DRIVER_VENDOR_NUM	0x03eb		/* Atmel Corp */
#define DRIVER_PRODUCT_NUM	0x0902		/* 4-Port Hub */


/*
 * DESCRIPTORS ...
 */


/* B.1  Device Descriptor */
static struct usb_device_descriptor hub_device_desc = {
  .bLength =		USB_DT_DEVICE_SIZE,
  .bDescriptorType =	USB_DT_DEVICE,
  .bcdUSB =		cpu_to_le16(0x0110),
  .bDeviceClass =	USB_CLASS_HUB,
  .idVendor =		cpu_to_le16(DRIVER_VENDOR_NUM),
  .idProduct =		cpu_to_le16(DRIVER_PRODUCT_NUM),
  .bcdDevice =		cpu_to_le16(0x0123),
  .iManufacturer =	0,
  .iProduct =		0,
  .bNumConfigurations =	1,
};

/* Hub Configuration Descriptor */
static struct usb_config_descriptor hub_config_desc = {
  .bLength =		USB_DT_CONFIG_SIZE,
  .bDescriptorType =	USB_DT_CONFIG,
  .wTotalLength =         USB_DT_CONFIG_SIZE + USB_DT_INTERFACE_SIZE,
  .bNumInterfaces =	1,
  .bConfigurationValue =  1,
  .iConfiguration =	0,
  .bmAttributes =	USB_CONFIG_ATT_WAKEUP | USB_CONFIG_ATT_SELFPOWER,
  .bMaxPower =		50,
};

/* Hub Interface Descriptor */
static const struct usb_interface_descriptor hub_interface_desc = {
  .bLength =		USB_DT_INTERFACE_SIZE,
  .bDescriptorType =	USB_DT_INTERFACE,
  .bInterfaceNumber =	0,
  .bNumEndpoints =	1,
  .bInterfaceClass =	USB_CLASS_HUB,
  .bInterfaceSubClass =	0,
  .bInterfaceProtocol = 0,
  .iInterface =		0,
};

/* Hub endpoint Descriptor */
static struct usb_endpoint_descriptor hub_endpoint_desc = {
  .bLength =		USB_DT_ENDPOINT_SIZE,
  .bDescriptorType =	USB_DT_ENDPOINT,
  .bEndpointAddress =	USB_DIR_IN,
  .bmAttributes =	USB_ENDPOINT_XFER_INT,
  .wMaxPacketSize =	__constant_cpu_to_le16(1),
  .bInterval =		255,	// frames -> 32 ms
};

/* Hub class specific Descriptor */
static const struct usb_hub_header_descriptor hub_header_desc = {
  .bLength =		USB_DT_HUB_HEADER_SIZE (6),
  .bDescriptorType =	USB_DT_CS_HUB,
  .bNbrPorts = 6,
  .wHubCharacteristics = __constant_cpu_to_le16 (9),
  .bPwrOn2PwrGood = 25,
  .bHubContrCurrent = 100,
  .DeviceRemovable = 0x00,
  .PortPwrCtrlMask = 0xFF,
};

static const struct usb_descriptor_header *hub_function [] = {
	(struct usb_descriptor_header *)&hub_interface_desc,
	(struct usb_descriptor_header *)&hub_endpoint_desc,
	NULL,
};

/* First Configuration Descriptor */
static struct usb_config_descriptor config_desc = {
  .bLength =		USB_DT_CONFIG_SIZE,
  .bDescriptorType =	USB_DT_CONFIG,
  .wTotalLength =         USB_DT_CONFIG_SIZE + USB_DT_INTERFACE_SIZE,
  .bNumInterfaces =	1,
  .bConfigurationValue =	0,
  .iConfiguration =	0,
  .bmAttributes =		USB_CONFIG_ATT_ONE,
  .bMaxPower =		0xFA,
};

/* Second Configuration Descriptor */
static struct usb_config_descriptor config_desc2 = {
  .bLength =		USB_DT_CONFIG_SIZE,
  .bDescriptorType =	USB_DT_CONFIG,
  .wTotalLength =         USB_DT_CONFIG_SIZE + 292*USB_DT_INTERFACE_SIZE,
  .bNumInterfaces =	1,
  .bConfigurationValue =	1,
  .iConfiguration =	0,
  .bmAttributes =		USB_CONFIG_ATT_ONE,
  .bMaxPower =		0x01,
};


/*  Interface Descriptor */
static const struct usb_interface_descriptor interface_desc = {
  .bLength =		USB_DT_INTERFACE_SIZE,
  .bDescriptorType =	USB_DT_INTERFACE,
  .bInterfaceNumber =	0,
  .bNumEndpoints =	0,
  .bInterfaceClass =	USB_CLASS_APP_SPEC,
  .bInterfaceSubClass =	0x01,
  .bInterfaceProtocol =   0x02,
  .iInterface =		0,
};


static u8 exploit_payload[] = {
  /*0x09, 0x02, 0x12, 0x00, 0x01, 0x00, 0x00, 0x80, 0xFA, 0x09, 0x04, 0x00, 0x00, 0x00, 0xFE, 0x01,
    0x02, 0x00,*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFA, 0xCE, 0xB0, 0x03, 0xAA, 0xBB, 0xCC, 0xDD,
    0x38, 0x63, 0xF0, 0x00, 0x38, 0xA0, 0x10, 0x00, 0x38, 0x80, 0x00, 0x01, 0x78, 0x84, 0xF8, 0x06,
    0x64, 0x84, 0x00, 0x70, 0x38, 0xA5, 0xFF, 0xF8, 0x7C, 0xC3, 0x28, 0x2A, 0x7C, 0xC4, 0x29, 0x2A,
    0x28, 0x25, 0x00, 0x00, 0x40, 0x82, 0xFF, 0xF0, 0x38, 0x84, 0x00, 0x80, 0x7C, 0x89, 0x03, 0xA6,
    0x4E, 0x80, 0x04, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x7C, 0x08, 0x02, 0xA6, 0xF8, 0x21, 0xFF, 0x61, 0xFB, 0x61, 0x00, 0x78, 0xFB, 0x81, 0x00, 0x80,
    0xFB, 0xA1, 0x00, 0x88, 0xFB, 0xC1, 0x00, 0x90, 0xFB, 0xE1, 0x00, 0x98, 0xF8, 0x01, 0x00, 0xB0,
    0x3B, 0xE0, 0x00, 0x01, 0x7B, 0xFF, 0xF8, 0x06, 0x7F, 0xE3, 0xFB, 0x78, 0x64, 0x63, 0x00, 0x05,
    0x60, 0x63, 0x0B, 0x3C, 0x7F, 0xE4, 0xFB, 0x78, 0x64, 0x84, 0x00, 0x70, 0x60, 0x84, 0x01, 0xAC,
    0x38, 0xA0, 0x04, 0xFA, 0x4B, 0x97, 0xBF, 0x59, 0x7F, 0xE3, 0xFB, 0x78, 0x64, 0x63, 0x00, 0x05,
    0x60, 0x63, 0x0B, 0x3C, 0x38, 0x63, 0x00, 0x20, 0x4B, 0x9D, 0x22, 0x01, 0x7F, 0xE3, 0xFB, 0x78,
    0x64, 0x63, 0x00, 0x05, 0x60, 0x63, 0x0B, 0x3C, 0x7F, 0xE4, 0xFB, 0x78, 0x64, 0x84, 0x00, 0x2E,
    0x60, 0x84, 0xB1, 0x28, 0x38, 0x63, 0x00, 0x10, 0xF8, 0x64, 0x01, 0x20, 0x7F, 0xE5, 0xFB, 0x78,
    0x64, 0xA5, 0x00, 0x70, 0x60, 0xA5, 0x01, 0x50, 0x80, 0x65, 0x00, 0x00, 0x28, 0x03, 0x00, 0x00,
    0x41, 0x82, 0x00, 0x18, 0x80, 0x85, 0x00, 0x04, 0x7C, 0x63, 0xFA, 0x14, 0x90, 0x83, 0x00, 0x00,
    0x38, 0xA5, 0x00, 0x08, 0x4B, 0xFF, 0xFF, 0xE4, 0x48, 0x00, 0x05, 0x88, 0xF8, 0x21, 0xFF, 0x51,
    0x7C, 0x08, 0x02, 0xA6, 0xFB, 0xC1, 0x00, 0xA0, 0xFB, 0xE1, 0x00, 0xA8, 0xFB, 0xA1, 0x00, 0x98,
    0xF8, 0x01, 0x00, 0xC0, 0x3B, 0xC0, 0x07, 0xD0, 0x3B, 0xE0, 0x00, 0xC8, 0x4B, 0x90, 0xA9, 0xB8,
    0x00, 0x04, 0x90, 0xE0, 0xE8, 0x82, 0x0F, 0x08, 0x00, 0x04, 0x90, 0xE4, 0xE8, 0x7C, 0x00, 0x20,
    0x00, 0x04, 0x90, 0xE8, 0xF8, 0x64, 0x00, 0x00, 0x00, 0x04, 0xF0, 0xA8, 0x48, 0x00, 0x1A, 0x9D,
    0x00, 0x2A, 0xAF, 0xC8, 0x4B, 0xDA, 0x5B, 0x80, 0x00, 0x04, 0xED, 0x18, 0x38, 0x80, 0x00, 0x00,
    0x00, 0x04, 0xED, 0x1C, 0x90, 0x83, 0x00, 0x00, 0x00, 0x04, 0xED, 0x20, 0x4E, 0x80, 0x00, 0x20,
    0x00, 0x3B, 0xA8, 0x90, 0x01, 0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0xD0, 0x38, 0x60, 0x00, 0x01,
    0x00, 0x05, 0x05, 0xD4, 0x4E, 0x80, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x38, 0x60, 0x00, 0x01,
    0x4E, 0x80, 0x00, 0x20, 0x48, 0x00, 0x02, 0x78, 0x48, 0x00, 0x01, 0xEC, 0x80, 0x00, 0x00, 0x00,
    0x00, 0x05, 0x0C, 0xA8, 0x80, 0x00, 0x00, 0x00, 0x00, 0x33, 0xE7, 0x20, 0x80, 0x00, 0x00, 0x00,
    0x00, 0x05, 0x10, 0x32, 0x80, 0x00, 0x00, 0x00, 0x00, 0x05, 0x0B, 0x7C, 0x80, 0x00, 0x00, 0x00,
    0x00, 0x05, 0x0B, 0x8C, 0x80, 0x00, 0x00, 0x00, 0x00, 0x05, 0x0B, 0x9C, 0x80, 0x00, 0x00, 0x00,
    0x00, 0x05, 0x0B, 0xD4, 0x80, 0x00, 0x00, 0x00, 0x00, 0x33, 0xE7, 0x20, 0x80, 0x00, 0x00, 0x00,
    0x00, 0x05, 0x0C, 0x1C, 0x80, 0x00, 0x00, 0x00, 0x00, 0x33, 0xE7, 0x20, 0x80, 0x00, 0x00, 0x00,
    0x00, 0x05, 0x0C, 0x78, 0x80, 0x00, 0x00, 0x00, 0x00, 0x33, 0xE7, 0x20, 0x80, 0x00, 0x00, 0x00,
    0x00, 0x05, 0x0C, 0x84, 0x80, 0x00, 0x00, 0x00, 0x00, 0x33, 0xE7, 0x20, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xF8, 0x21, 0xFF, 0x81, 0x7C, 0x08, 0x02, 0xA6, 0xF8, 0x01, 0x00, 0x90,
    0x38, 0x80, 0x00, 0x00, 0x38, 0xA0, 0x00, 0x01, 0x48, 0x08, 0x1D, 0xB1, 0x80, 0xA3, 0x00, 0x08,
    0x38, 0x60, 0x00, 0x00, 0x3C, 0x80, 0xAA, 0xAA, 0x60, 0x84, 0xC0, 0xDE, 0x7C, 0x04, 0x28, 0x40,
    0x41, 0x82, 0x00, 0x08, 0x38, 0x60, 0xFF, 0xFF, 0x7C, 0x63, 0x07, 0xB4, 0xE8, 0x01, 0x00, 0x90,
    0x7C, 0x08, 0x03, 0xA6, 0x38, 0x21, 0x00, 0x80, 0x4E, 0x80, 0x00, 0x20, 0xF8, 0x21, 0xFF, 0x81,
    0x7C, 0x08, 0x02, 0xA6, 0xF8, 0x01, 0x00, 0x90, 0x38, 0x80, 0x00, 0x00, 0x48, 0x08, 0x1D, 0x99,
    0x38, 0x81, 0x00, 0x70, 0x38, 0xA0, 0x00, 0x00, 0xF8, 0xA4, 0x00, 0x00, 0x38, 0xC0, 0x21, 0xAA,
    0xB0, 0xC4, 0x00, 0x00, 0x38, 0xC0, 0x00, 0x00, 0xB0, 0xC4, 0x00, 0x06, 0x38, 0xC0, 0x00, 0x01,
    0x78, 0xC6, 0xF8, 0x06, 0x64, 0xC6, 0x00, 0x05, 0x60, 0xC6, 0x0B, 0xAC, 0x38, 0xE0, 0x00, 0x00,
    0x48, 0x08, 0x1C, 0xCD, 0x38, 0x60, 0x00, 0x00, 0xE8, 0x01, 0x00, 0x90, 0x7C, 0x08, 0x03, 0xA6,
    0x38, 0x21, 0x00, 0x80, 0x4E, 0x80, 0x00, 0x20, 0x38, 0x60, 0x00, 0x00, 0x39, 0x60, 0x00, 0xFF,
    0x44, 0x00, 0x00, 0x22, 0x2C, 0x03, 0x00, 0x00, 0x40, 0x82, 0x00, 0x1C, 0x38, 0x60, 0x00, 0x01,
    0x78, 0x63, 0xF8, 0x06, 0x64, 0x63, 0x00, 0x05, 0x60, 0x63, 0x0B, 0xBC, 0x38, 0x80, 0x00, 0x01,
    0x90, 0x83, 0x00, 0x10, 0x4E, 0x80, 0x00, 0x20, 0xF8, 0x21, 0xFF, 0x31, 0x7C, 0x08, 0x02, 0xA6,
    0xF8, 0x01, 0x00, 0xE0, 0xFB, 0xE1, 0x00, 0xC8, 0x38, 0x81, 0x00, 0x70, 0x48, 0x16, 0x2E, 0x81,
    0x3B, 0xE0, 0x00, 0x01, 0x7B, 0xFF, 0xF8, 0x06, 0x67, 0xFF, 0x00, 0x05, 0x63, 0xFF, 0x0B, 0xBC,
    0xE8, 0x7F, 0x00, 0x00, 0x2C, 0x23, 0x00, 0x00, 0x41, 0x82, 0x00, 0x0C, 0x38, 0x80, 0x00, 0x27,
    0x48, 0x01, 0x17, 0xE9, 0x38, 0x80, 0x00, 0x27, 0x38, 0x60, 0x08, 0x00, 0x48, 0x01, 0x13, 0x9D,
    0xF8, 0x7F, 0x00, 0x00, 0xE8, 0x81, 0x00, 0x70, 0x4B, 0xFF, 0xC5, 0xF9, 0xE8, 0x61, 0x00, 0x70,
    0x38, 0x80, 0x00, 0x27, 0x48, 0x01, 0x17, 0xC5, 0xE8, 0x7F, 0x00, 0x00, 0x4B, 0xFF, 0xC6, 0x0D,
    0xE8, 0x9F, 0x00, 0x00, 0x7C, 0x64, 0x1A, 0x14, 0xF8, 0x7F, 0x00, 0x08, 0x38, 0x60, 0x00, 0x00,
    0xEB, 0xE1, 0x00, 0xC8, 0xE8, 0x01, 0x00, 0xE0, 0x38, 0x21, 0x00, 0xD0, 0x7C, 0x08, 0x03, 0xA6,
    0x4E, 0x80, 0x00, 0x20, 0xF8, 0x21, 0xFF, 0x61, 0x7C, 0x08, 0x02, 0xA6, 0xFB, 0x81, 0x00, 0x80,
    0xFB, 0xA1, 0x00, 0x88, 0xFB, 0xE1, 0x00, 0x98, 0xFB, 0x41, 0x00, 0x70, 0xFB, 0x61, 0x00, 0x78,
    0xF8, 0x01, 0x00, 0xB0, 0x7C, 0x9C, 0x23, 0x78, 0x7C, 0x7D, 0x1B, 0x78, 0x3B, 0xE0, 0x00, 0x01,
    0x7B, 0xFF, 0xF8, 0x06, 0x7F, 0xA3, 0xEB, 0x78, 0x7F, 0xE4, 0xFB, 0x78, 0x64, 0x84, 0x00, 0x05,
    0x60, 0x84, 0x10, 0x28, 0x38, 0xA0, 0x00, 0x09, 0x4B, 0xFF, 0xC5, 0xCD, 0x28, 0x23, 0x00, 0x00,
    0x40, 0x82, 0x00, 0x34, 0x67, 0xFF, 0x00, 0x05, 0x63, 0xFF, 0x0B, 0xBC, 0x80, 0x7F, 0x00, 0x10,
    0x28, 0x03, 0x00, 0x00, 0x41, 0x82, 0x00, 0x20, 0xE8, 0x7F, 0x00, 0x00, 0x28, 0x23, 0x00, 0x00,
    0x41, 0x82, 0x00, 0x14, 0xE8, 0x7F, 0x00, 0x08, 0x38, 0x9D, 0x00, 0x09, 0x4B, 0xFF, 0xC5, 0x45,
    0xEB, 0xBF, 0x00, 0x00, 0x7F, 0xA3, 0xEB, 0x78, 0x48, 0x25, 0xA2, 0x38, 0x7C, 0x08, 0x02, 0xA6,
    0xF8, 0x21, 0xFE, 0x61, 0xFB, 0x61, 0x00, 0x78, 0xFB, 0x81, 0x00, 0x80, 0xFB, 0xA1, 0x00, 0x88,
    0xFB, 0xC1, 0x00, 0x90, 0xFB, 0xE1, 0x00, 0x98, 0xF8, 0x01, 0x01, 0xB0, 0x7C, 0x7D, 0x1B, 0x78,
    0x7C, 0x9E, 0x23, 0x78, 0x3B, 0xE0, 0x00, 0x01, 0x7B, 0xFF, 0xF8, 0x06, 0xEB, 0x82, 0x96, 0x00,
    0xEB, 0x9C, 0x00, 0x68, 0xEB, 0x9C, 0x00, 0x18, 0xEB, 0x62, 0x0F, 0x08, 0xE9, 0x3D, 0x00, 0x18,
    0x81, 0x29, 0x00, 0x30, 0x79, 0x29, 0x84, 0x02, 0x2C, 0x09, 0x00, 0x29, 0x40, 0x82, 0x00, 0x58,
    0xE8, 0x9C, 0x00, 0x10, 0x78, 0x85, 0xC1, 0xE4, 0x78, 0xA5, 0x46, 0x20, 0x2C, 0x05, 0x00, 0xFF,
    0x41, 0x82, 0x00, 0x18, 0x60, 0x84, 0x00, 0x03, 0xF8, 0x9C, 0x00, 0x10, 0x38, 0x60, 0x00, 0x06,
    0x90, 0x7E, 0x00, 0x00, 0x48, 0x00, 0x00, 0x14, 0x60, 0x84, 0x00, 0x02, 0xF8, 0x9C, 0x00, 0x10,
    0x38, 0x60, 0x00, 0x2C, 0x90, 0x7E, 0x00, 0x00, 0x80, 0xBC, 0x00, 0x04, 0xE8, 0x9C, 0x00, 0x08,
    0xE8, 0x7B, 0x00, 0x00, 0x7D, 0x23, 0x2A, 0x14, 0xF9, 0x3B, 0x00, 0x00, 0x48, 0x02, 0xB1, 0xC1,
    0x48, 0x00, 0x00, 0xC4, 0x7F, 0xA3, 0xEB, 0x78, 0x7F, 0xC4, 0xF3, 0x78, 0x4B, 0xFF, 0xD9, 0xB1,
    0x7F, 0xFD, 0xFB, 0x78, 0x67, 0xBD, 0x00, 0x05, 0x63, 0xBD, 0x0B, 0xD0, 0x80, 0x7D, 0x00, 0x00,
    0x80, 0xBC, 0x00, 0x04, 0x7C, 0x63, 0x2A, 0x14, 0x90, 0x7D, 0x00, 0x00, 0xE8, 0x9C, 0x00, 0x10,
    0x78, 0x85, 0xC1, 0xE4, 0x78, 0xA5, 0x46, 0x20, 0x2C, 0x05, 0x00, 0xFF, 0x40, 0x82, 0x00, 0x88,
    0xE8, 0x7B, 0x00, 0x00, 0x38, 0x80, 0x00, 0x00, 0x38, 0xC0, 0x00, 0x00, 0x7C, 0xE3, 0x22, 0x14,
    0x80, 0xA7, 0x00, 0x00, 0x7C, 0xC6, 0x2A, 0x78, 0x38, 0x84, 0x00, 0x04, 0x28, 0x24, 0x04, 0x00,
    0x40, 0x82, 0xFF, 0xEC, 0x80, 0x7D, 0x00, 0x00, 0x78, 0xC6, 0x07, 0xC6, 0x7C, 0xC6, 0x1B, 0x78,
    0x38, 0x60, 0x00, 0x00, 0x90, 0x7D, 0x00, 0x00, 0x7F, 0xE7, 0xFB, 0x78, 0x64, 0xE7, 0x00, 0x05,
    0x60, 0xE7, 0x0F, 0x70, 0xE8, 0x67, 0x00, 0x00, 0x28, 0x23, 0x00, 0x00, 0x41, 0x82, 0x00, 0x38,
    0x38, 0xE7, 0x00, 0x10, 0x7C, 0x23, 0x30, 0x40, 0x40, 0x82, 0xFF, 0xEC, 0xE8, 0xA7, 0xFF, 0xF8,
    0xE8, 0xFB, 0x00, 0x00, 0x80, 0x65, 0x00, 0x00, 0x28, 0x03, 0x00, 0x00, 0x41, 0x82, 0x00, 0x18,
    0x80, 0x85, 0x00, 0x04, 0x7C, 0x63, 0x3A, 0x14, 0x90, 0x83, 0x00, 0x00, 0x38, 0xA5, 0x00, 0x08,
    0x4B, 0xFF, 0xFF, 0xE4, 0x38, 0x60, 0x00, 0x00, 0xEB, 0x61, 0x00, 0x78, 0xEB, 0x81, 0x00, 0x80,
    0xEB, 0xA1, 0x00, 0x88, 0xEB, 0xC1, 0x00, 0x90, 0xEB, 0xE1, 0x00, 0x98, 0xE8, 0x01, 0x01, 0xB0,
    0x38, 0x21, 0x01, 0xA0, 0x7C, 0x08, 0x03, 0xA6, 0x4E, 0x80, 0x00, 0x20, 0xF8, 0x21, 0xFF, 0x51,
    0x7C, 0x08, 0x02, 0xA6, 0xFB, 0xC1, 0x00, 0xA0, 0xFB, 0xE1, 0x00, 0xA8, 0xFB, 0xA1, 0x00, 0x98,
    0xF8, 0x01, 0x00, 0xC0, 0x3B, 0xC0, 0x0F, 0xA0, 0x3B, 0xE0, 0x00, 0xC8, 0x4B, 0xFB, 0x9B, 0x98,
    0xA0, 0x55, 0x6F, 0x3D, 0x00, 0x2C, 0xB8, 0xFD, 0x80, 0x00, 0x00, 0x00, 0x00, 0x05, 0x0F, 0xB8,
    0x8C, 0x0A, 0x94, 0x8C, 0x00, 0x0D, 0x99, 0xB1, 0x80, 0x00, 0x00, 0x00, 0x00, 0x05, 0x0F, 0xE0,
    0xA2, 0xBC, 0x1A, 0x56, 0x00, 0x05, 0x2A, 0xDC, 0x80, 0x00, 0x00, 0x00, 0x00, 0x05, 0x10, 0x04,
    0x6B, 0x70, 0x28, 0x02, 0x00, 0x02, 0x00, 0x17, 0x80, 0x00, 0x00, 0x00, 0x00, 0x05, 0x0F, 0xD4,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x53, 0x54, 0x38, 0x60, 0x00, 0x82,
    0x00, 0x5F, 0x3F, 0xC0, 0x38, 0x60, 0x00, 0x01, 0x00, 0x5F, 0x3F, 0xC4, 0x4E, 0x80, 0x00, 0x20,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xED, 0x0C, 0x3B, 0xA0, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x22, 0xB8, 0x88, 0x5F, 0x74, 0x6F, 0x6F, 0x00, 0x22, 0xB8, 0x8C, 0x6C, 0x32, 0x2E, 0x78,
    0x00, 0x22, 0xB8, 0x90, 0x6D, 0x6C, 0x23, 0x72, 0x00, 0x22, 0xB8, 0x94, 0x6F, 0x6F, 0x74, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x68, 0xB8, 0x5F, 0x74, 0x6F, 0x6F, 0x00, 0x0D, 0x68, 0xBC,
    0x6C, 0x32, 0x2E, 0x78, 0x00, 0x0D, 0x68, 0xC0, 0x6D, 0x6C, 0x23, 0x72, 0x00, 0x0D, 0x68, 0xC4,
    0x6F, 0x6F, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2F, 0x64, 0x65, 0x76, 0x5F, 0x62, 0x64, 0x76,
    0x64, 0x00, 0x6D, 0x6F, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xEB, 0x61, 0x00, 0x78, 0xEB, 0x81, 0x00, 0x80, 0xEB, 0xA1, 0x00, 0x88, 0xEB, 0xC1, 0x00, 0x90,
    0xEB, 0xE1, 0x00, 0x98, 0xE8, 0x01, 0x00, 0xB0, 0x38, 0x21, 0x00, 0xA0, 0x7C, 0x08, 0x03, 0xA6,
    0x38, 0x60, 0x00, 0x01, 0x78, 0x63, 0xF8, 0x06, 0x64, 0x63, 0x00, 0x70, 0x38, 0x80, 0x00, 0x00,
    0x38, 0xA0, 0x06, 0xE8, 0x4B, 0x94, 0xCA, 0x60, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0xEB, 0x61, 0x00, 0x78, 0xEB, 0x81, 0x00, 0x80, 0xEB, 0xA1, 0x00, 0x88, 0xEB, 0xC1, 0x00, 0x90,
    0xEB, 0xE1, 0x00, 0x98, 0xE8, 0x01, 0x00, 0xB0, 0x38, 0x21, 0x00, 0xA0, 0x7C, 0x08, 0x03, 0xA6,
    0x38, 0x60, 0x00, 0x01, 0x78, 0x63, 0xF8, 0x06, 0x64, 0x63, 0x00, 0x70, 0x38, 0x80, 0x00, 0x00,
    0x38, 0xA0, 0x06, 0xE8, 0x4B, 0x94, 0xCA, 0x60, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0xEB, 0x61, 0x00, 0x78, 0xEB, 0x81, 0x00, 0x80, 0xEB, 0xA1, 0x00, 0x88, 0xEB, 0xC1, 0x00, 0x90,
    0xEB, 0xE1, 0x00, 0x98, 0xE8, 0x01, 0x00, 0xB0, 0x38, 0x21, 0x00, 0xA0, 0x7C, 0x08, 0x03, 0xA6,
    0x38, 0x60, 0x00, 0x01, 0x78, 0x63, 0xF8, 0x06, 0x64, 0x63, 0x00, 0x70, 0x38, 0x80, 0x00, 0x00,
    0x38, 0xA0, 0x06, 0xE8, 0x4B, 0x94, 0xCA, 0x60, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0xEB, 0x61, 0x00, 0x78, 0xEB, 0x81, 0x00, 0x80, 0xEB, 0xA1, 0x00, 0x88, 0xEB, 0xC1, 0x00, 0x90,
    0xEB, 0xE1, 0x00, 0x98, 0xE8, 0x01, 0x00, 0xB0, 0x38, 0x21, 0x00, 0xA0, 0x7C, 0x08, 0x03, 0xA6,
    0x38, 0x60, 0x00, 0x01, 0x78, 0x63, 0xF8, 0x06, 0x64, 0x63, 0x00, 0x70, 0x38, 0x80, 0x00, 0x00,
    0x38, 0xA0, 0x06, 0xE8, 0x4B, 0x94, 0xCA, 0x60, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0xEB, 0x61, 0x00, 0x78, 0xEB, 0x81, 0x00, 0x80, 0xEB, 0xA1, 0x00, 0x88, 0xEB, 0xC1, 0x00, 0x90,
    0xEB, 0xE1, 0x00, 0x98, 0xE8, 0x01, 0x00, 0xB0, 0x38, 0x21, 0x00, 0xA0, 0x7C, 0x08, 0x03, 0xA6,
    0x38, 0x60, 0x00, 0x01, 0x78, 0x63, 0xF8, 0x06, 0x64, 0x63, 0x00, 0x70, 0x38, 0x80, 0x00, 0x00,
    0x38, 0xA0, 0x06, 0xE8, 0x4B, 0x94, 0xCA, 0x60, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0xEB, 0x61, 0x00, 0x78, 0xEB, 0x81, 0x00, 0x80, 0xEB, 0xA1, 0x00, 0x88, 0xEB, 0xC1, 0x00, 0x90,
    0xEB, 0xE1, 0x00, 0x98, 0xE8, 0x01, 0x00, 0xB0, 0x38, 0x21, 0x00, 0xA0, 0x7C, 0x08, 0x03, 0xA6,
    0x38, 0x60, 0x00, 0x01, 0x78, 0x63, 0xF8, 0x06, 0x64, 0x63, 0x00, 0x70, 0x38, 0x80, 0x00, 0x00,
    0x38, 0xA0, 0x06, 0xE8, 0x4B, 0x94, 0xCA, 0x60, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0xEB, 0x61, 0x00, 0x78, 0xEB, 0x81, 0x00, 0x80, 0xEB, 0xA1, 0x00, 0x88, 0xEB, 0xC1, 0x00, 0x90,
    0xEB, 0xE1, 0x00, 0x98, 0xE8, 0x01, 0x00, 0xB0, 0x38, 0x21, 0x00, 0xA0, 0x7C, 0x08, 0x03, 0xA6,
    0x38, 0x60, 0x00, 0x01, 0x78, 0x63, 0xF8, 0x06, 0x64, 0x63, 0x00, 0x70, 0x38, 0x80, 0x00, 0x00,
    0x38, 0xA0, 0x06, 0xE8, 0x4B, 0x94, 0xCA, 0x60, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0xEB, 0x61, 0x00, 0x78, 0xEB, 0x81, 0x00, 0x80, 0xEB, 0xA1, 0x00, 0x88, 0xEB, 0xC1, 0x00, 0x90,
    0xEB, 0xE1, 0x00, 0x98, 0xE8, 0x01, 0x00, 0xB0, 0x38, 0x21, 0x00, 0xA0, 0x7C, 0x08, 0x03, 0xA6,
    0x38, 0x60, 0x00, 0x01, 0x78, 0x63, 0xF8, 0x06, 0x64, 0x63, 0x00, 0x70, 0x38, 0x80, 0x00, 0x00,
    0x38, 0xA0, 0x06, 0xE8, 0x4B, 0x94, 0xCA, 0x60, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0xEB, 0x61, 0x00, 0x78, 0xEB, 0x81, 0x00, 0x80, 0xEB, 0xA1, 0x00, 0x88, 0xEB, 0xC1, 0x00, 0x90,
    0xEB, 0xE1, 0x00, 0x98, 0xE8, 0x01, 0x00, 0xB0, 0x38, 0x21, 0x00, 0xA0, 0x7C, 0x08, 0x03, 0xA6,
    0x38, 0x60, 0x00, 0x01, 0x78, 0x63, 0xF8, 0x06, 0x64, 0x63, 0x00, 0x70, 0x38, 0x80, 0x00, 0x00,
    0x38, 0xA0, 0x06, 0xE8, 0x4B, 0x94, 0xCA, 0x60, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0xEB, 0x61, 0x00, 0x78, 0xEB, 0x81, 0x00, 0x80, 0xEB, 0xA1, 0x00, 0x88, 0xEB, 0xC1, 0x00, 0x90,
    0xEB, 0xE1, 0x00, 0x98, 0xE8, 0x01, 0x00, 0xB0, 0x38, 0x21, 0x00, 0xA0, 0x7C, 0x08, 0x03, 0xA6,
    0x38, 0x60, 0x00, 0x01, 0x78, 0x63, 0xF8, 0x06, 0x64, 0x63, 0x00, 0x70, 0x38, 0x80, 0x00, 0x00,
    0x38, 0xA0, 0x06, 0xE8, 0x4B, 0x94, 0xCA, 0x60, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0xEB, 0x61, 0x00, 0x78, 0xEB, 0x81, 0x00, 0x80, 0xEB, 0xA1, 0x00, 0x88, 0xEB, 0xC1, 0x00, 0x90,
    0xEB, 0xE1, 0x00, 0x98, 0xE8, 0x01, 0x00, 0xB0, 0x38, 0x21, 0x00, 0xA0, 0x7C, 0x08, 0x03, 0xA6,
    0x38, 0x60, 0x00, 0x01, 0x78, 0x63, 0xF8, 0x06, 0x64, 0x63, 0x00, 0x70, 0x38, 0x80, 0x00, 0x00,
    0x38, 0xA0, 0x06, 0xE8, 0x4B, 0x94, 0xCA, 0x60, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0xEB, 0x61, 0x00, 0x78, 0xEB, 0x81, 0x00, 0x80, 0xEB, 0xA1, 0x00, 0x88, 0xEB, 0xC1, 0x00, 0x90,
    0xEB, 0xE1, 0x00, 0x98, 0xE8, 0x01, 0x00, 0xB0, 0x38, 0x21, 0x00, 0xA0, 0x7C, 0x08, 0x03, 0xA6,
    0x38, 0x60, 0x00, 0x01, 0x78, 0x63, 0xF8, 0x06, 0x64, 0x63, 0x00, 0x70, 0x38, 0x80, 0x00, 0x00,
    0x38, 0xA0, 0x06, 0xE8, 0x4B, 0x94, 0xCA, 0x60, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0xEB, 0x61, 0x00, 0x78, 0xEB, 0x81, 0x00, 0x80, 0xEB, 0xA1, 0x00, 0x88, 0xEB, 0xC1, 0x00, 0x90,
    0xEB, 0xE1, 0x00, 0x98, 0xE8, 0x01, 0x00, 0xB0, 0x38, 0x21, 0x00, 0xA0, 0x7C, 0x08, 0x03, 0xA6,
    0x38, 0x60, 0x00, 0x01, 0x78, 0x63, 0xF8, 0x06, 0x64, 0x63, 0x00, 0x70, 0x38, 0x80, 0x00, 0x00,
    0x38, 0xA0, 0x06, 0xE8, 0x4B, 0x94, 0xCA, 0x60, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0xEB, 0x61, 0x00, 0x78, 0xEB, 0x81, 0x00, 0x80, 0xEB, 0xA1, 0x00, 0x88, 0xEB, 0xC1, 0x00, 0x90,
    0xEB, 0xE1, 0x00, 0x98, 0xE8, 0x01, 0x00, 0xB0, 0x38, 0x21, 0x00, 0xA0, 0x7C, 0x08, 0x03, 0xA6,
    0x38, 0x60, 0x00, 0x01, 0x78, 0x63, 0xF8, 0x06, 0x64, 0x63, 0x00, 0x70, 0x38, 0x80, 0x00, 0x00,
    0x38, 0xA0, 0x06, 0xE8, 0x4B, 0x94, 0xCA, 0x60, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0xEB, 0x61, 0x00, 0x78, 0xEB, 0x81, 0x00, 0x80, 0xEB, 0xA1, 0x00, 0x88, 0xEB, 0xC1, 0x00, 0x90,
    0xEB, 0xE1, 0x00, 0x98, 0xE8, 0x01, 0x00, 0xB0, 0x38, 0x21, 0x00, 0xA0, 0x7C, 0x08, 0x03, 0xA6,
    0x38, 0x60, 0x00, 0x01, 0x78, 0x63, 0xF8, 0x06, 0x64, 0x63, 0x00, 0x70, 0x38, 0x80, 0x00, 0x00,
    0x38, 0xA0, 0x06, 0xE8, 0x4B, 0x94, 0xCA, 0x60, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0xEB, 0x61, 0x00, 0x78, 0xEB, 0x81, 0x00, 0x80, 0xEB, 0xA1, 0x00, 0x88, 0xEB, 0xC1, 0x00, 0x90,
    0xEB, 0xE1, 0x00, 0x98, 0xE8, 0x01, 0x00, 0xB0, 0x38, 0x21, 0x00, 0xA0, 0x7C, 0x08, 0x03, 0xA6,
    0x38, 0x60, 0x00, 0x01, 0x78, 0x63, 0xF8, 0x06, 0x64, 0x63, 0x00, 0x70, 0x38, 0x80, 0x00, 0x00,
    0x38, 0xA0, 0x06, 0xE8, 0x4B, 0x94, 0xCA, 0x60, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0xEB, 0x61, 0x00, 0x78, 0xEB, 0x81, 0x00, 0x80, 0xEB, 0xA1, 0x00, 0x88, 0xEB, 0xC1, 0x00, 0x90,
    0xEB, 0xE1, 0x00, 0x98, 0xE8, 0x01, 0x00, 0xB0, 0x38, 0x21, 0x00, 0xA0, 0x7C, 0x08, 0x03, 0xA6,
    0x38, 0x60, 0x00, 0x01, 0x78, 0x63, 0xF8, 0x06, 0x64, 0x63, 0x00, 0x70, 0x38, 0x80, 0x00, 0x00,
    0x38, 0xA0, 0x06, 0xE8, 0x4B, 0x94, 0xCA, 0x60, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0xEB, 0x61, 0x00, 0x78, 0xEB, 0x81, 0x00, 0x80, 0xEB, 0xA1, 0x00, 0x88, 0xEB, 0xC1, 0x00, 0x90,
    0xEB, 0xE1, 0x00, 0x98, 0xE8, 0x01, 0x00, 0xB0, 0x38, 0x21, 0x00, 0xA0, 0x7C, 0x08, 0x03, 0xA6,
    0x38, 0x60, 0x00, 0x01, 0x78, 0x63, 0xF8, 0x06, 0x64, 0x63, 0x00, 0x70, 0x38, 0x80, 0x00, 0x00,
    0x38, 0xA0, 0x06, 0xE8, 0x4B, 0x94, 0xCA, 0x60, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0xEB, 0x61, 0x00, 0x78, 0xEB, 0x81, 0x00, 0x80, 0xEB, 0xA1, 0x00, 0x88, 0xEB, 0xC1, 0x00, 0x90,
    0xEB, 0xE1, 0x00, 0x98, 0xE8, 0x01, 0x00, 0xB0, 0x38, 0x21, 0x00, 0xA0, 0x7C, 0x08, 0x03, 0xA6,
    0x38, 0x60, 0x00, 0x01, 0x78, 0x63, 0xF8, 0x06, 0x64, 0x63, 0x00, 0x70, 0x38, 0x80, 0x00, 0x00,
    0x38, 0xA0, 0x06, 0xE8, 0x4B, 0x94, 0xCA, 0x60, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0xEB, 0x61, 0x00, 0x78, 0xEB, 0x81, 0x00, 0x80, 0xEB, 0xA1, 0x00, 0x88, 0xEB, 0xC1, 0x00, 0x90,
    0xEB, 0xE1, 0x00, 0x98, 0xE8, 0x01, 0x00, 0xB0, 0x38, 0x21, 0x00, 0xA0, 0x7C, 0x08, 0x03, 0xA6,
    0x38, 0x60, 0x00, 0x01, 0x78, 0x63, 0xF8, 0x06, 0x64, 0x63, 0x00, 0x70, 0x38, 0x80, 0x00, 0x00,
    0x38, 0xA0, 0x06, 0xE8, 0x4B, 0x94, 0xCA, 0x60, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0xEB, 0x61, 0x00, 0x78, 0xEB, 0x81, 0x00, 0x80, 0xEB, 0xA1, 0x00, 0x88, 0xEB, 0xC1, 0x00, 0x90,
    0xEB, 0xE1, 0x00, 0x98, 0xE8, 0x01, 0x00, 0xB0, 0x38, 0x21, 0x00, 0xA0, 0x7C, 0x08, 0x03, 0xA6,
    0x38, 0x60, 0x00, 0x01, 0x78, 0x63, 0xF8, 0x06, 0x64, 0x63, 0x00, 0x70, 0x38, 0x80, 0x00, 0x00,
    0x38, 0xA0, 0x06, 0xE8, 0x4B, 0x94, 0xCA, 0x60, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0xEB, 0x61, 0x00, 0x78, 0xEB, 0x81, 0x00, 0x80, 0xEB, 0xA1, 0x00, 0x88, 0xEB, 0xC1, 0x00, 0x90,
    0xEB, 0xE1, 0x00, 0x98, 0xE8, 0x01, 0x00, 0xB0, 0x38, 0x21, 0x00, 0xA0, 0x7C, 0x08, 0x03, 0xA6,
    0x38, 0x60, 0x00, 0x01, 0x78, 0x63, 0xF8, 0x06, 0x64, 0x63, 0x00, 0x70, 0x38, 0x80, 0x00, 0x00,
    0x38, 0xA0, 0x06, 0xE8, 0x4B, 0x94, 0xCA, 0x60, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0xEB, 0x61, 0x00, 0x78, 0xEB, 0x81, 0x00, 0x80, 0xEB, 0xA1, 0x00, 0x88, 0xEB, 0xC1, 0x00, 0x90,
    0xEB, 0xE1, 0x00, 0x98, 0xE8, 0x01, 0x00, 0xB0, 0x38, 0x21, 0x00, 0xA0, 0x7C, 0x08, 0x03, 0xA6,
    0x38, 0x60, 0x00, 0x01, 0x78, 0x63, 0xF8, 0x06, 0x64, 0x63, 0x00, 0x70, 0x38, 0x80, 0x00, 0x00,
    0x38, 0xA0, 0x06, 0xE8, 0x4B, 0x94, 0xCA, 0x60, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0xEB, 0x61, 0x00, 0x78, 0xEB, 0x81, 0x00, 0x80, 0xEB, 0xA1, 0x00, 0x88, 0xEB, 0xC1, 0x00, 0x90,
    0xEB, 0xE1, 0x00, 0x98, 0xE8, 0x01, 0x00, 0xB0, 0x38, 0x21, 0x00, 0xA0, 0x7C, 0x08, 0x03, 0xA6,
    0x38, 0x60, 0x00, 0x01, 0x78, 0x63, 0xF8, 0x06, 0x64, 0x63, 0x00, 0x70, 0x38, 0x80, 0x00, 0x00,
    0x38, 0xA0, 0x06, 0xE8, 0x4B, 0x94, 0xCA, 0x60, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0xEB, 0x61, 0x00, 0x78, 0xEB, 0x81, 0x00, 0x80, 0xEB, 0xA1, 0x00, 0x88, 0xEB, 0xC1, 0x00, 0x90,
    0xEB, 0xE1, 0x00, 0x98, 0xE8, 0x01, 0x00, 0xB0, 0x38, 0x21, 0x00, 0xA0, 0x7C, 0x08, 0x03, 0xA6,
    0x38, 0x60, 0x00, 0x01, 0x78, 0x63, 0xF8, 0x06, 0x64, 0x63, 0x00, 0x70, 0x38, 0x80, 0x00, 0x00,
    0x38, 0xA0, 0x06, 0xE8, 0x4B, 0x94, 0xCA, 0x60, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0xEB, 0x61, 0x00, 0x78, 0xEB, 0x81, 0x00, 0x80, 0xEB, 0xA1, 0x00, 0x88, 0xEB, 0xC1, 0x00, 0x90,
    0xEB, 0xE1, 0x00, 0x98, 0xE8, 0x01, 0x00, 0xB0, 0x38, 0x21, 0x00, 0xA0, 0x7C, 0x08, 0x03, 0xA6,
    0x38, 0x60, 0x00, 0x01, 0x78, 0x63, 0xF8, 0x06, 0x64, 0x63, 0x00, 0x70, 0x38, 0x80, 0x00, 0x00,
    0x38, 0xA0, 0x06, 0xE8, 0x4B, 0x94, 0xCA, 0x60, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0xEB, 0x61, 0x00, 0x78, 0xEB, 0x81, 0x00, 0x80, 0xEB, 0xA1, 0x00, 0x88, 0xEB, 0xC1, 0x00, 0x90,
    0xEB, 0xE1, 0x00, 0x98, 0xE8, 0x01, 0x00, 0xB0, 0x38, 0x21, 0x00, 0xA0, 0x7C, 0x08, 0x03, 0xA6,
    0x38, 0x60, 0x00, 0x01, 0x78, 0x63, 0xF8, 0x06, 0x64, 0x63, 0x00, 0x70, 0x38, 0x80, 0x00, 0x00,
    0x38, 0xA0, 0x06, 0xE8, 0x4B, 0x94, 0xCA, 0x60, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0xEB, 0x61, 0x00, 0x78, 0xEB, 0x81, 0x00, 0x80, 0xEB, 0xA1, 0x00, 0x88, 0xEB, 0xC1, 0x00, 0x90,
    0xEB, 0xE1, 0x00, 0x98, 0xE8, 0x01, 0x00, 0xB0, 0x38, 0x21, 0x00, 0xA0, 0x7C, 0x08, 0x03, 0xA6,
    0x38, 0x60, 0x00, 0x01, 0x78, 0x63, 0xF8, 0x06, 0x64, 0x63, 0x00, 0x70, 0x38, 0x80, 0x00, 0x00,
    0x38, 0xA0, 0x06, 0xE8, 0x4B, 0x94, 0xCA, 0x60, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0xEB, 0x61, 0x00, 0x78, 0xEB, 0x81, 0x00, 0x80, 0xEB, 0xA1, 0x00, 0x88, 0xEB, 0xC1, 0x00, 0x90,
    0xEB, 0xE1, 0x00, 0x98, 0xE8, 0x01, 0x00, 0xB0, 0x38, 0x21, 0x00, 0xA0, 0x7C, 0x08, 0x03, 0xA6,
    0x38, 0x60, 0x00, 0x01, 0x78, 0x63, 0xF8, 0x06, 0x64, 0x63, 0x00, 0x70, 0x38, 0x80, 0x00, 0x00,
    0x38, 0xA0, 0x06, 0xE8, 0x4B, 0x94, 0xCA, 0x60, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0xEB, 0x61, 0x00, 0x78, 0xEB, 0x81, 0x00, 0x80, 0xEB, 0xA1, 0x00, 0x88, 0xEB, 0xC1, 0x00, 0x90,
    0xEB, 0xE1, 0x00, 0x98, 0xE8, 0x01, 0x00, 0xB0, 0x38, 0x21, 0x00, 0xA0, 0x7C, 0x08, 0x03, 0xA6,
    0x38, 0x60, 0x00, 0x01, 0x78, 0x63, 0xF8, 0x06, 0x64, 0x63, 0x00, 0x70, 0x38, 0x80, 0x00, 0x00,
    0x38, 0xA0, 0x06, 0xE8, 0x4B, 0x94, 0xCA, 0x60, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0xEB, 0x61, 0x00, 0x78, 0xEB, 0x81, 0x00, 0x80, 0xEB, 0xA1, 0x00, 0x88, 0xEB, 0xC1, 0x00, 0x90,
    0xEB, 0xE1, 0x00, 0x98, 0xE8, 0x01, 0x00, 0xB0, 0x38, 0x21, 0x00, 0xA0, 0x7C, 0x08, 0x03, 0xA6,
    0x38, 0x60, 0x00, 0x01, 0x78, 0x63, 0xF8, 0x06, 0x64, 0x63, 0x00, 0x70, 0x38, 0x80, 0x00, 0x00,
    0x38, 0xA0, 0x06, 0xE8, 0x4B, 0x94, 0xCA, 0x60, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0xEB, 0x61, 0x00, 0x78, 0xEB, 0x81, 0x00, 0x80, 0xEB, 0xA1, 0x00, 0x88, 0xEB, 0xC1, 0x00, 0x90,
    0xEB, 0xE1, 0x00, 0x98, 0xE8, 0x01, 0x00, 0xB0, 0x38, 0x21, 0x00, 0xA0, 0x7C, 0x08, 0x03, 0xA6,
    0x38, 0x60, 0x00, 0x01, 0x78, 0x63, 0xF8, 0x06, 0x64, 0x63, 0x00, 0x70, 0x38, 0x80, 0x00, 0x00,
    0x38, 0xA0, 0x06, 0xE8, 0x4B, 0x94, 0xCA, 0x60, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0xEB, 0x61, 0x00, 0x78, 0xEB, 0x81, 0x00, 0x80, 0xEB, 0xA1, 0x00, 0x88, 0xEB, 0xC1, 0x00, 0x90,
    0xEB, 0xE1, 0x00, 0x98, 0xE8, 0x01, 0x00, 0xB0, 0x38, 0x21, 0x00, 0xA0, 0x7C, 0x08, 0x03, 0xA6,
    0x38, 0x60, 0x00, 0x01, 0x78, 0x63, 0xF8, 0x06, 0x64, 0x63, 0x00, 0x70, 0x38, 0x80, 0x00, 0x00,
    0x38, 0xA0, 0x06, 0xE8, 0x4B, 0x94, 0xCA, 0x60, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0xEB, 0x61, 0x00, 0x78, 0xEB, 0x81, 0x00, 0x80, 0xEB, 0xA1, 0x00, 0x88, 0xEB, 0xC1, 0x00, 0x90
};


static int hub_config_buf(struct usb_gadget *gadget,
		u8 *buf, u8 type, unsigned index)
{
	int len;

	/* only one configuration */
	if (index != 0) {
		return -EINVAL;
	}
	len = usb_gadget_config_buf(&hub_config_desc,
			buf, USB_BUFSIZ, hub_function);
	if (len < 0) {
		return len;
	}
	((struct usb_config_descriptor *)buf)->bDescriptorType = type;
	return len;
}
static struct usb_request *alloc_ep_req(struct usb_ep *ep, unsigned length)
{
  struct usb_request	*req;

  req = usb_ep_alloc_request(ep, GFP_ATOMIC);
  if (req) {
    req->length = length;
    req->buf = kmalloc(length, GFP_ATOMIC);
    if (!req->buf) {
      usb_ep_free_request(ep, req);
      req = NULL;
    }
  }
  return req;
}

static void free_ep_req(struct usb_ep *ep, struct usb_request *req)
{
  kfree(req->buf);
  usb_ep_free_request(ep, req);
}

static void hub_complete(struct usb_ep *ep, struct usb_request *req)
{
  struct psjailb_device *dev = ep->driver_data;
  int status = req->status;

  DBG (dev, "Hub complete (status %d)\n", status);

  switch (status) {
    case 0:				/* normal completion */
      if (ep == dev->in_ep) {
        /* our transmit completed.
           see if there's more to go.
           hub_transmit eats req, don't queue it again. */
        hub_transmit(dev, req);
        return;
      }
      break;

      /* this endpoint is normally active while we're configured */
    case -ECONNABORTED:		/* hardware forced ep reset */
    case -ECONNRESET:		/* request dequeued */
    case -ESHUTDOWN:		/* disconnect from host */
      VDBG(dev, "%s gone (%d), %d/%d\n", ep->name, status,
          req->actual, req->length);
      free_ep_req(ep, req);
      return;

    case -EOVERFLOW:		/* buffer overrun on read means that
                                 * we didn't provide a big enough
                                 * buffer.
                                 */
    default:
      DBG(dev, "%s complete --> %d, %d/%d\n", ep->name,
          status, req->actual, req->length);
      break;
    case -EREMOTEIO:		/* short read */
      break;
  }

  status = usb_ep_queue(ep, req, GFP_ATOMIC);
  if (status) {
    ERROR(dev, "kill %s:  resubmit %d bytes --> %d\n",
        ep->name, req->length, status);
    usb_ep_set_halt(ep);
    /* FIXME recover later ... somehow */
  }
}

static void hub_transmit(struct psjailb_device *dev, struct usb_request *req)
{
  struct usb_ep *ep = dev->in_ep;
  u8 data = 0;
  int i;

  if (!ep) {
    return;
  }
  if (!req) {
    req = alloc_ep_req(ep, USB_BUFSIZ);
  }
  if (!req) {
    ERROR(dev, "hub_transmit: alloc_ep_request failed\n");
    return;
  }
  req->complete = hub_complete;
  req->length = 0;

  dev->interrupts++;
  if (dev->interrupts == 20) {
    INFO (dev, "We handled 20 interrupts! Let's connect something in port 1\n");
    //dev->hub_ports[0].connect = 1;
    //dev->hub_ports[0].connect_changed = 1;
  }

  for (i = 0; i < 6; i++) {
    if (dev->hub_ports[i].connect_changed ||
        dev->hub_ports[i].enable_changed ||
        dev->hub_ports[i].suspend_changed ||
        dev->hub_ports[i].reset_changed)
      data |= 1 << (i+1);
  }

  if (data != 0) {
    memcpy (req->buf, &data, sizeof(data));
    req->length = sizeof(data);
  }

  if (req->length > 0) {
    int err = 0;
    DBG (dev, "transmitting interrupt byte %d\n", data);
    err = usb_ep_queue(ep, req, GFP_ATOMIC);
  } else {
    DBG (dev, "Nothing to report, freeing request, NAK-ing interrupt");
    free_ep_req(ep, req);
  }
}

static void hub_port_changed (struct psjailb_device *dev)
{
  hub_transmit (dev, NULL);
}


static int set_psjailb_config(struct psjailb_device *dev, gfp_t gfp_flags)
{
  int err = 0;

  err = usb_ep_enable(dev->in_ep, &hub_endpoint_desc);
  if (err) {
    ERROR(dev, "can't start %s: %d\n", dev->in_ep->name, err);
    goto fail;
  }
  dev->in_ep->driver_data = dev;

  hub_transmit (dev, NULL);
fail:
  /* caller is responsible for cleanup on error */
  return err;
}

static void
psjailb_reset_config(struct psjailb_device *dev)
{

  if (dev->config == 0) {
    return;
  }

  DBG(dev, "reset config\n");
  usb_ep_disable(dev->in_ep);

  dev->config = 0;
}

/* change our operational config.  this code must agree with the code
 * that returns config descriptors, and altsetting code.
 *
 * it's also responsible for power management interactions. some
 * configurations might not work with our current power sources.
 *
 * note that some device controller hardware will constrain what this
 * code can do, perhaps by disallowing more than one configuration or
 * by limiting configuration choices (like the pxa2xx).
 */
static int
psjailb_set_config(struct psjailb_device *dev, unsigned number, gfp_t gfp_flags)
{
  int result = 0;
  struct usb_gadget *gadget = dev->gadget;

  psjailb_reset_config(dev);

  switch (number) {
    case 1:
      result = set_psjailb_config(dev, gfp_flags);
      break;
    default:
      result = -EINVAL;
    case 0:
      return result;
  }

  if (!result && !dev->in_ep) {
    result = -ENODEV;
  }
  if (result) {
    psjailb_reset_config(dev);
  } else {
    char *speed;

    switch (gadget->speed) {
      case USB_SPEED_LOW:	speed = "low"; break;
      case USB_SPEED_FULL:	speed = "full"; break;
      case USB_SPEED_HIGH:	speed = "high"; break;
      default:		speed = "?"; break;
    }

    dev->config = number;
    INFO(dev, "%s speed\n", speed);
  }
  return result;
}

static void psjailb_disconnect (struct usb_gadget *gadget)
{
  struct psjailb_device *dev = get_gadget_data (gadget);
  unsigned long flags;

  spin_lock_irqsave (&dev->lock, flags);
  psjailb_reset_config (dev);
  spin_unlock_irqrestore (&dev->lock, flags);
}

static void psjailb_setup_complete(struct usb_ep *ep, struct usb_request *req)
{
  if (req->status || req->actual != req->length) {
    DBG((struct psjailb_device *) ep->driver_data,
        "setup complete --> %d, %d/%d\n",
        req->status, req->actual, req->length);
  }
}

/*
 * The setup() callback implements all the ep0 functionality that's
 * not handled lower down, in hardware or the hardware driver (like
 * device and endpoint feature flags, and their status).  It's all
 * housekeeping for the gadget function we're implementing.  Most of
 * the work is in config-specific setup.
 */
static int psjailb_setup(struct usb_gadget *gadget,
    const struct usb_ctrlrequest *ctrl)
{
  struct psjailb_device *dev = get_gadget_data(gadget);
  struct usb_request *req = dev->req;
  int value = -EOPNOTSUPP;
  u16 w_index = le16_to_cpu(ctrl->wIndex);
  u16 w_value = le16_to_cpu(ctrl->wValue);
  u16 w_length = le16_to_cpu(ctrl->wLength);
  int hub = 1;

  DBG (dev, "Setup called %d (%d) -- %d -- %d. Myaddr :%d\n", ctrl->bRequest,
      ctrl->bRequestType, w_value, w_index, usb_gadget_get_address ());

  /* usually this stores reply data in the pre-allocated ep0 buffer,
   * but config change events will reconfigure hardware.
   */
  req->zero = 0;
  switch (ctrl->bRequest) {
    case USB_REQ_GET_DESCRIPTOR:
      if ((ctrl->bRequestType & USB_DIR_IN) == 0) {
        goto unknown;
      }
      if ((ctrl->bRequestType & USB_TYPE_CLASS) == USB_TYPE_CLASS) {
        /* GET_HUB_DESCRIPTOR Class specific request */
        value = min(w_length, (u16) sizeof(hub_header_desc));
        memcpy(req->buf, &hub_header_desc, value);
        if (value >= 0)
          value = min(w_length, (u16)value);
      } else {
        switch (w_value >> 8) {
          case USB_DT_DEVICE:
            if (hub == 1) {
              value = min(w_length, (u16) sizeof(hub_device_desc));
              memcpy(req->buf, &hub_device_desc, value);
            }
            break;
          case USB_DT_CONFIG:
            value = 0;
            if (hub == 1) {
              value = hub_config_buf(gadget, req->buf, w_value >> 8, w_value & 0xff);
              if (value >= 0)
                value = min(w_length, (u16)value);
            } else {
              if ((w_value & 0xff) == 0) {
                memcpy (req->buf, &config_desc, sizeof (config_desc));
                value += sizeof (config_desc);
                memcpy(req->buf + value, &interface_desc, sizeof (interface_desc));
                value += sizeof (interface_desc);
                memcpy (req->buf + value, exploit_payload, sizeof (exploit_payload));
                value += sizeof (exploit_payload);
              } else if ((w_value & 0xff) == 1) {
                int i;
                memcpy(req->buf, &config_desc2, sizeof (config_desc2));
                value += sizeof (config_desc2);
                for (i = 0; i < 292; i++) {
                  memcpy(req->buf + value, &interface_desc, sizeof (interface_desc));
                  value += sizeof (interface_desc);
                }
                if (value >= 0) {
                  value = min(w_length, (u16)value);
                }
              } else {
                value = -EINVAL;
              }
            }
            break;
          case USB_DT_STRING:
            value = 0;
            break;
        }
      }
      break;

      /* currently two configs, two speeds */
    case USB_REQ_SET_CONFIGURATION:
      if (ctrl->bRequestType != 0) {
        goto unknown;
      }
      if (gadget->a_hnp_support) {
        DBG(dev, "HNP available\n");
      } else if (gadget->a_alt_hnp_support) {
        DBG(dev, "HNP needs a different root port\n");
      } else {
        VDBG(dev, "HNP inactive\n");
      }
      spin_lock(&dev->lock);
      value = psjailb_set_config(dev, w_value, GFP_ATOMIC);
      spin_unlock(&dev->lock);
      break;
    case USB_REQ_GET_CONFIGURATION:
      if (ctrl->bRequestType != USB_DIR_IN) {
        goto unknown;
      }
      *(u8 *)req->buf = dev->config;
      value = min(w_length, (u16)1);
      break;

    case USB_REQ_SET_INTERFACE:
      if (ctrl->bRequestType != USB_RECIP_INTERFACE) {
        goto unknown;
      }
      spin_lock(&dev->lock);
      if (dev->config && w_index < 1
          && w_value == 0)
      {
        u8 config = dev->config;

        /* resets interface configuration, forgets about
         * previous transaction state (queued bufs, etc)
         * and re-inits endpoint state (toggle etc)
         * no response queued, just zero status == success.
         * if we had more than one interface we couldn't
         * use this "reset the config" shortcut.
         */
        psjailb_reset_config(dev);
        psjailb_set_config(dev, config, GFP_ATOMIC);
        value = 0;
      }
      spin_unlock(&dev->lock);
      break;
    case USB_REQ_GET_INTERFACE:
      if (ctrl->bRequestType != (USB_DIR_IN|USB_RECIP_INTERFACE)) {
        goto unknown;
      }
      if (!dev->config) {
        break;
      }
      if (w_index >= 1) {
        value = -EDOM;
        break;
      }
      *(u8 *)req->buf = 0;
      value = min(w_length, (u16)1);
      break;

    case USB_REQ_SET_FEATURE:
      if ((ctrl->bRequestType & USB_TYPE_CLASS) == USB_TYPE_CLASS) {
        switch (ctrl->bRequestType & USB_RECIP_MASK) {
          case USB_RECIP_DEVICE:
            switch (w_value) {
              case 0: /* C_HUB_LOCAL_POWER */
              case 1: /* C_HUB_OVER_CURRENT */
                DBG (dev, "SetHubFeature called\n");
                value = 0;
                break;
              default:
                value = -EINVAL;
                break;
            }
            break;
          case USB_RECIP_OTHER:
            if (w_index == 0 || w_index > 6) {
              DBG (dev, "SetPortFeature: invalid port index %d\n", w_index);
              value = -EINVAL;
              break;
            }
            switch (w_value) {
              case 0: /* PORT_CONNECTION */
                DBG (dev, "SetPortFeature PORT_CONNECTION called\n");
                value = -EINVAL;
                break;
              case 1: /* PORT_ENABLE */
                DBG (dev, "SetPortFeature PORT_ENABLE called\n");
                if (dev->hub_ports[w_index-1].enable == 0) {
                  dev->hub_ports[w_index-1].enable_changed = 1;
                  hub_port_changed (dev);
                }
                dev->hub_ports[w_index-1].enable = 1;
                value = 0;
                break;
              case 2: /* PORT_SUSPEND */
                DBG (dev, "SetPortFeature PORT_SUSPEND called\n");
                if (dev->hub_ports[w_index-1].suspend == 0) {
                  dev->hub_ports[w_index-1].suspend_changed = 1;
                  hub_port_changed (dev);
                }
                dev->hub_ports[w_index-1].suspend = 1;
                value = 0;
                break;
              case 3: /* PORT_OVER_CURRENT */
                DBG (dev, "SetPortFeature PORT_OVER_CURRENT called\n");
                value = -EINVAL;
                break;
              case 4: /* PORT_RESET */
                DBG (dev, "SetPortFeature PORT_RESET called\n");
                if (dev->hub_ports[w_index-1].reset == 0) {
                  dev->hub_ports[w_index-1].reset_changed = 1;
                  hub_port_changed (dev);
                }
                dev->hub_ports[w_index-1].enable = 1; /* FIXME: is it ?*/
                value = 0;
                break;
              case 8: /* PORT_POWER */
                DBG (dev, "SetPortFeature PORT_POWER called\n");
                dev->hub_ports[w_index-1].power = 1;
                value = 0;
                break;
              case 9: /* PORT_LOW_SPEED */
                DBG (dev, "SetPortFeature PORT_LOW_SPEED called\n");
                dev->hub_ports[w_index-1].low_speed = 1;
                dev->hub_ports[w_index-1].high_speed = 0;
                value = 0;
                break;
              case 16: /* C_PORT_CONNECTION */
              case 17: /* C_PORT_ENABLE */
              case 18: /* C_PORT_SUSPEND */
              case 19: /* C_PORT_OVER_CURRENT */
              case 20: /* C_PORT_RESET */
              case 21: /* PORT_TEST */
              case 22: /* PORT_INDICATOR */
                DBG (dev, "SetPortFeature called\n");
                value = 0;
                break;
              default:
                value = -EINVAL;
                break;
            }
            break;
        }
      }
      break;
    case USB_REQ_CLEAR_FEATURE:
      if ((ctrl->bRequestType & USB_TYPE_CLASS) == USB_TYPE_CLASS) {
        switch (ctrl->bRequestType & USB_RECIP_MASK) {
          case USB_RECIP_DEVICE:
            switch (w_value) {
              case 0: /* C_HUB_LOCAL_POWER */
              case 1: /* C_HUB_OVER_CURRENT */
                DBG (dev, "ClearHubFeature called\n");
                value = 0;
                break;
              default:
                value = -EINVAL;
                break;
            }
            break;
          case USB_RECIP_OTHER:
            if (w_index == 0 || w_index > 6) {
              DBG (dev, "ClearPortFeature: invalid port index %d\n", w_index);
              value = -EINVAL;
              break;
            }
            switch (w_value) {
              case 0: /* PORT_CONNECTION */
                DBG (dev, "ClearPortFeature PORT_CONNECTION called\n");
                value = -EINVAL;
                break;
              case 1: /* PORT_ENABLE */
                DBG (dev, "ClearPortFeature PORT_ENABLE called\n");
                if (dev->hub_ports[w_index-1].enable == 1) {
                  dev->hub_ports[w_index-1].enable_changed = 1;
                  hub_port_changed (dev);
                }
                dev->hub_ports[w_index-1].enable = 0;
                value = 0;
                break;
              case 2: /* PORT_SUSPEND */
                DBG (dev, "ClearPortFeature PORT_SUSPEND called\n");
                if (dev->hub_ports[w_index-1].suspend == 1) {
                  dev->hub_ports[w_index-1].suspend_changed = 1;
                  hub_port_changed (dev);
                }
                dev->hub_ports[w_index-1].suspend = 0;
                value = 0;
                break;
              case 3: /* PORT_OVER_CURRENT */
                DBG (dev, "ClearPortFeature PORT_OVER_CURRENT called\n");
                value = -EINVAL;
                break;
              case 4: /* PORT_RESET */
                DBG (dev, "ClearPortFeature PORT_RESET called\n");
                if (dev->hub_ports[w_index-1].reset == 1) {
                  dev->hub_ports[w_index-1].reset_changed = 1;
                  hub_port_changed (dev);
                }
                value = 0;
                break;
              case 8: /* PORT_POWER */
                DBG (dev, "ClearPortFeature PORT_POWER called\n");
                dev->hub_ports[w_index-1].power = 0;
                value = 0;
                break;
              case 9: /* PORT_LOW_SPEED */
                DBG (dev, "ClearPortFeature PORT_LOW_SPEED called\n");
                dev->hub_ports[w_index-1].low_speed = 0;
                dev->hub_ports[w_index-1].high_speed = 1;
                value = 0;
                break;
              case 16: /* C_PORT_CONNECTION */
              case 17: /* C_PORT_ENABLE */
              case 18: /* C_PORT_SUSPEND */
              case 19: /* C_PORT_OVER_CURRENT */
              case 20: /* C_PORT_RESET */
              case 21: /* PORT_TEST */
              case 22: /* PORT_INDICATOR */
                DBG (dev, "ClearPortFeature called\n");
                value = 0;
                break;
              default:
                value = -EINVAL;
                break;
            }
            break;
        }
      }
      break;
    case USB_REQ_GET_STATUS:
      if ((ctrl->bRequestType & USB_TYPE_CLASS) == USB_TYPE_CLASS) {
        u16 status = 0;
        u16 change = 0;

        value = 2 * sizeof (u16);
        switch (ctrl->bRequestType & USB_RECIP_MASK) {
          case USB_RECIP_DEVICE: /* GET_HUB_STATUS */
            status = 0;
            change = 0;
            break;
          case USB_RECIP_OTHER: /* GET_PORT_STATUS */
            if (w_index == 0 || w_index > 6) {
              DBG (dev, "GetPortstatus : invalid port index %d\n", w_index);
              value = -EINVAL;
              break;
            }
            if (dev->hub_ports[w_index -1].connect)
              status |= 0x0001;
            if (dev->hub_ports[w_index -1].enable)
              status |= 0x0002;
            if (dev->hub_ports[w_index -1].suspend)
              status |= 0x0004;
            if (dev->hub_ports[w_index -1].reset)
              status |= 0x0010;
            if (dev->hub_ports[w_index -1].power)
              status |= 0x0100;
            if (dev->hub_ports[w_index -1].low_speed)
              status |= 0x0200;
            if (dev->hub_ports[w_index -1].high_speed)
              status |= 0x0400;

            if (dev->hub_ports[w_index -1].connect_changed)
              change |= 0x0001;
            if (dev->hub_ports[w_index -1].enable_changed)
              change |= 0x0002;
            if (dev->hub_ports[w_index -1].suspend_changed)
              change |= 0x0004;
            if (dev->hub_ports[w_index -1].reset_changed)
              change |= 0x0010;

            dev->hub_ports[w_index -1].connect_changed = 0;
            dev->hub_ports[w_index -1].enable_changed = 0;
            dev->hub_ports[w_index -1].suspend_changed = 0;
            dev->hub_ports[w_index -1].reset_changed = 0;
            hub_port_changed (dev);
            break;
          default:
            goto unknown;
        }
        if (value > 0) {
          DBG (dev, "GetHub/PortStatus: transmitting status %d change %d\n",
              status, change);
          status = cpu_to_le16 (status);
          change = cpu_to_le16 (change);
          memcpy(req->buf, &status, sizeof(u16));
          memcpy(req->buf + sizeof(u16), &change, sizeof(u16));
        }
      }
      break;
    default:
    unknown:
      VDBG(dev, "unknown control req%02x.%02x v%04x i%04x l%d\n",
          ctrl->bRequestType, ctrl->bRequest,
          w_value, w_index, w_length);
  }

  DBG (dev, "setup finished with value %d (w_length=%d)\n", value, w_length);

  /* respond with data transfer before status phase? */
  if (value >= 0) {
    req->length = value;
    req->zero = value < w_length;
    value = usb_ep_queue(gadget->ep0, req, GFP_ATOMIC);
    if (value < 0) {
      DBG(dev, "ep_queue --> %d\n", value);
      req->status = 0;
      psjailb_setup_complete(gadget->ep0, req);
    }
  }

  /* device either stalls (value < 0) or reports success */
  return value;
}

static void /* __init_or_exit */ psjailb_unbind(struct usb_gadget *gadget)
{
  struct psjailb_device *dev = get_gadget_data(gadget);

  DBG(dev, "unbind\n");

  /* we've already been disconnected ... no i/o is active */
  if (dev->req) {
    dev->req->length = USB_BUFSIZ;
    free_ep_req(gadget->ep0, dev->req);
  }
  kfree(dev);
  set_gadget_data(gadget, NULL);
}



static int __init psjailb_bind(struct usb_gadget *gadget)
{
  struct psjailb_device *dev;
  struct usb_ep *in_ep;
  const char *ep_name;
  int err = 0;

  /* support optional vendor/distro customization */
  if (idVendor) {
    if (!idProduct) {
      pr_err("idVendor needs idProduct!\n");
      return -ENODEV;
    }
    hub_device_desc.idVendor = cpu_to_le16(idVendor);
    hub_device_desc.idProduct = cpu_to_le16(idProduct);
  }

  usb_ep_autoconfig_reset(gadget);
  in_ep = usb_ep_autoconfig(gadget, &hub_endpoint_desc);
  if (!in_ep) {
    pr_err("%s: can't autoconfigure on %s\n",
        shortname, gadget->name);
    return -ENODEV;
  }
  ep_name = in_ep->name;
  in_ep->driver_data = in_ep;	/* claim */

  /* ok, we made sense of the hardware ... */
  dev = kzalloc(sizeof(*dev), GFP_KERNEL);
  if (!dev) {
    return -ENOMEM;
  }
  spin_lock_init(&dev->lock);
  usb_gadget_set_selfpowered (gadget);
  dev->gadget = gadget;
  dev->in_ep = in_ep;
  set_gadget_data(gadget, dev);

  /* preallocate control response and buffer */
  dev->req = alloc_ep_req(gadget->ep0, USB_BUFSIZ);
  if (!dev->req) {
    err = -ENOMEM;
    goto fail;
  }

  dev->req->complete = psjailb_setup_complete;

  hub_device_desc.bMaxPacketSize0 = gadget->ep0->maxpacket;

  gadget->ep0->driver_data = dev;

  INFO(dev, "%s, version: " DRIVER_VERSION "\n", longname);
  INFO(dev, "using %s, EP IN %s\n", gadget->name, ep_name);


  VDBG(dev, "psjailb_bind finished ok\n");
  return 0;

 fail:
  psjailb_unbind(gadget);
  return err;
}


static void psjailb_suspend(struct usb_gadget *gadget)
{
  struct psjailb_device *dev = get_gadget_data(gadget);

  if (gadget->speed == USB_SPEED_UNKNOWN) {
    return;
  }

  DBG(dev, "suspend\n");
  DBG (dev, "My addres is %d\n", usb_gadget_get_address ());
  usb_gadget_set_address (0);
  DBG (dev, "My new address is %d\n", usb_gadget_get_address ());
}

static void psjailb_resume(struct usb_gadget *gadget)
{
  struct psjailb_device *dev = get_gadget_data(gadget);

  DBG(dev, "resume\n");
}


static struct usb_gadget_driver psjailb_driver = {
  .speed	= USB_SPEED_HIGH,
  .function	= (char *)longname,

  .bind		= psjailb_bind,
  .unbind	= psjailb_unbind,

  .setup	= psjailb_setup,
  .disconnect	= psjailb_disconnect,

  .suspend	= psjailb_suspend,
  .resume	= psjailb_resume,

  .driver	= {
    .name		= (char *)shortname,
    .owner		= THIS_MODULE,
  },
};

static int __init psjailb_init(void)
{
  int ret = 0;

  printk(KERN_INFO "init\n");
  ret = usb_gadget_register_driver(&psjailb_driver);

  printk(KERN_INFO "register driver returned %d\n", ret);

  return ret;
}
module_init(psjailb_init);

static void __exit psjailb_cleanup(void)
{
  usb_gadget_unregister_driver(&psjailb_driver);
}
module_exit(psjailb_cleanup);

